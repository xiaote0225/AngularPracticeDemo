var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/common/schematics/add/index", ["require", "exports", "@angular-devkit/core", "@angular-devkit/schematics", "@schematics/angular/utility/dependencies", "@schematics/angular/utility/json-file", "@schematics/angular/utility/workspace", "typescript", "@nguniversal/common/schematics/utils/index"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addUniversalCommonRule = void 0;
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const core_1 = require("@angular-devkit/core");
    const schematics_1 = require("@angular-devkit/schematics");
    const dependencies_1 = require("@schematics/angular/utility/dependencies");
    const json_file_1 = require("@schematics/angular/utility/json-file");
    const workspace_1 = require("@schematics/angular/utility/workspace");
    const ts = require("typescript");
    const utils_1 = require("@nguniversal/common/schematics/utils/index");
    const SERVE_SSR_TARGET_NAME = 'serve-ssr';
    const PRERENDER_TARGET_NAME = 'prerender';
    function addUniversalCommonRule(options) {
        return (host) => __awaiter(this, void 0, void 0, function* () {
            const clientProject = yield utils_1.getProject(host, options.clientProject);
            return schematics_1.chain([
                clientProject.targets.has('server')
                    ? schematics_1.noop()
                    : schematics_1.externalSchematic('@schematics/angular', 'universal', Object.assign(Object.assign({}, options), { skipInstall: true })),
                addScriptsRule(options),
                updateServerTsConfigRule(options),
                updateWorkspaceConfigRule(options),
                routingInitialNavigationRule(options),
                addDependencies(),
            ]);
        });
    }
    exports.addUniversalCommonRule = addUniversalCommonRule;
    function addScriptsRule(options) {
        return (host) => __awaiter(this, void 0, void 0, function* () {
            const pkgPath = '/package.json';
            const buffer = host.read(pkgPath);
            if (buffer === null) {
                throw new schematics_1.SchematicsException('Could not find package.json');
            }
            const serverDist = yield utils_1.getOutputPath(host, options.clientProject, 'server');
            const pkg = JSON.parse(buffer.toString());
            pkg.scripts = Object.assign(Object.assign({}, pkg.scripts), { 'dev:ssr': `ng run ${options.clientProject}:${SERVE_SSR_TARGET_NAME}`, 'serve:ssr': `node ${serverDist}/main.js`, 'build:ssr': `ng build --prod && ng run ${options.clientProject}:server:production`, 'prerender': `ng run ${options.clientProject}:${PRERENDER_TARGET_NAME}` });
            host.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        });
    }
    function updateWorkspaceConfigRule(options) {
        return () => {
            return workspace_1.updateWorkspace(workspace => {
                const projectName = options.clientProject;
                const project = workspace.projects.get(projectName);
                if (!project) {
                    return;
                }
                const serverTarget = project.targets.get('server');
                serverTarget.options.main = core_1.join(core_1.normalize(project.root), utils_1.stripTsExtension(options.serverFileName) + '.ts');
                const serveSSRTarget = project.targets.get(SERVE_SSR_TARGET_NAME);
                if (serveSSRTarget) {
                    return;
                }
                project.targets.add({
                    name: SERVE_SSR_TARGET_NAME,
                    builder: '@nguniversal/builders:ssr-dev-server',
                    options: {
                        browserTarget: `${projectName}:build`,
                        serverTarget: `${projectName}:server`,
                    },
                    configurations: {
                        production: {
                            browserTarget: `${projectName}:build:production`,
                            serverTarget: `${projectName}:server:production`,
                        },
                    },
                });
                const prerenderTarget = project.targets.get(PRERENDER_TARGET_NAME);
                if (prerenderTarget) {
                    return;
                }
                project.targets.add({
                    name: PRERENDER_TARGET_NAME,
                    builder: '@nguniversal/builders:prerender',
                    options: {
                        browserTarget: `${projectName}:build:production`,
                        serverTarget: `${projectName}:server:production`,
                        routes: ['/']
                    },
                    // Add a dummy production config to be consistent with other targets.
                    configurations: {
                        production: {},
                    },
                });
            });
        };
    }
    function updateServerTsConfigRule(options) {
        return (host) => __awaiter(this, void 0, void 0, function* () {
            const clientProject = yield utils_1.getProject(host, options.clientProject);
            const serverTarget = clientProject.targets.get('server');
            if (!serverTarget || !serverTarget.options) {
                return;
            }
            const tsConfigPath = serverTarget.options.tsConfig;
            if (!tsConfigPath || typeof tsConfigPath !== 'string') {
                // No tsconfig path
                return;
            }
            const tsConfig = new json_file_1.JSONFile(host, tsConfigPath);
            const filesAstNode = tsConfig.get(['files']);
            const serverFilePath = utils_1.stripTsExtension(options.serverFileName) + '.ts';
            if (Array.isArray(filesAstNode) && !filesAstNode.some(({ text }) => text === serverFilePath)) {
                tsConfig.modify(['files'], [
                    ...filesAstNode,
                    serverFilePath
                ]);
            }
        });
    }
    function routingInitialNavigationRule(options) {
        return (host) => __awaiter(this, void 0, void 0, function* () {
            const clientProject = yield utils_1.getProject(host, options.clientProject);
            const serverTarget = clientProject.targets.get('server');
            if (!serverTarget || !serverTarget.options) {
                return;
            }
            const tsConfigPath = serverTarget.options.tsConfig;
            if (!tsConfigPath || typeof tsConfigPath !== 'string' || !host.exists(tsConfigPath)) {
                // No tsconfig path
                return;
            }
            const parseConfigHost = {
                useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
                readDirectory: ts.sys.readDirectory,
                fileExists: function (fileName) {
                    return host.exists(fileName);
                },
                readFile: function (fileName) {
                    return host.read(fileName).toString();
                },
            };
            const { config } = ts.readConfigFile(tsConfigPath, parseConfigHost.readFile);
            const parsed = ts.parseJsonConfigFileContent(config, parseConfigHost, core_1.dirname(core_1.normalize(tsConfigPath)));
            const tsHost = ts.createCompilerHost(parsed.options, true);
            // Strip BOM as otherwise TSC methods (Ex: getWidth) will return an offset,
            // which breaks the CLI UpdateRecorder.
            // See: https://github.com/angular/angular/pull/30719
            tsHost.readFile = function (fileName) {
                return host.read(fileName).toString().replace(/^\uFEFF/, '');
            };
            tsHost.directoryExists = function (directoryName) {
                // When the path is file getDir will throw.
                try {
                    const dir = host.getDir(directoryName);
                    return !!(dir.subdirs.length || dir.subfiles.length);
                }
                catch (_a) {
                    return false;
                }
            };
            tsHost.fileExists = function (fileName) {
                return host.exists(fileName);
            };
            tsHost.realpath = function (path) {
                return path;
            },
                tsHost.getCurrentDirectory = function () {
                    return host.root.path;
                };
            const program = ts.createProgram(parsed.fileNames, parsed.options, tsHost);
            const typeChecker = program.getTypeChecker();
            const sourceFiles = program.getSourceFiles().filter(f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));
            const printer = ts.createPrinter();
            const routerModule = 'RouterModule';
            const routerSource = '@angular/router';
            sourceFiles.forEach(sourceFile => {
                const routerImport = utils_1.findImport(sourceFile, routerSource, routerModule);
                if (!routerImport) {
                    return;
                }
                let routerModuleNode;
                ts.forEachChild(sourceFile, function visitNode(node) {
                    if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&
                        ts.isIdentifier(node.expression.expression) && node.expression.name.text === 'forRoot') {
                        const imp = utils_1.getImportOfIdentifier(typeChecker, node.expression.expression);
                        if (imp && imp.name === routerModule && imp.importModule === routerSource) {
                            routerModuleNode = node;
                        }
                    }
                    ts.forEachChild(node, visitNode);
                });
                if (routerModuleNode) {
                    const print = printer.printNode(ts.EmitHint.Unspecified, utils_1.addInitialNavigation(routerModuleNode), sourceFile);
                    const recorder = host.beginUpdate(sourceFile.fileName);
                    recorder.remove(routerModuleNode.getStart(), routerModuleNode.getWidth());
                    recorder.insertRight(routerModuleNode.getStart(), print);
                    host.commitUpdate(recorder);
                }
            });
        });
    }
    function addDependencies() {
        return host => {
            dependencies_1.addPackageJsonDependency(host, {
                name: '@nguniversal/builders',
                type: dependencies_1.NodeDependencyType.Dev,
                version: '^11.0.1',
            });
            return host;
        };
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2NvbW1vbi9zY2hlbWF0aWNzL2FkZC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBQTs7Ozs7O09BTUc7SUFDSCwrQ0FBZ0U7SUFDaEUsMkRBTW9DO0lBRXBDLDJFQUF3RztJQUN4RyxxRUFBaUU7SUFDakUscUVBQXdFO0lBQ3hFLGlDQUFpQztJQUVqQyxzRUFPa0I7SUFFbEIsTUFBTSxxQkFBcUIsR0FBRyxXQUFXLENBQUM7SUFDMUMsTUFBTSxxQkFBcUIsR0FBRyxXQUFXLENBQUM7SUFNMUMsU0FBZ0Isc0JBQXNCLENBQUMsT0FBNEI7UUFDakUsT0FBTyxDQUFNLElBQUksRUFBQyxFQUFFO1lBQ2xCLE1BQU0sYUFBYSxHQUFHLE1BQU0sa0JBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLE9BQU8sa0JBQUssQ0FBQztnQkFDWCxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7b0JBQ2pDLENBQUMsQ0FBQyxpQkFBSSxFQUFFO29CQUNSLENBQUMsQ0FBQyw4QkFBaUIsQ0FBQyxxQkFBcUIsRUFBRSxXQUFXLGtDQUNqRCxPQUFPLEtBQ1YsV0FBVyxFQUFFLElBQUksSUFDakI7Z0JBQ0osY0FBYyxDQUFDLE9BQU8sQ0FBQztnQkFDdkIsd0JBQXdCLENBQUMsT0FBTyxDQUFDO2dCQUNqQyx5QkFBeUIsQ0FBQyxPQUFPLENBQUM7Z0JBQ2xDLDRCQUE0QixDQUFDLE9BQU8sQ0FBQztnQkFDckMsZUFBZSxFQUFFO2FBQ2xCLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQSxDQUFDO0lBQ0osQ0FBQztJQWxCRCx3REFrQkM7SUFFRCxTQUFTLGNBQWMsQ0FBQyxPQUE0QjtRQUNsRCxPQUFPLENBQU0sSUFBSSxFQUFDLEVBQUU7WUFDbEIs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ZCxDQUFDLENBQUM7SUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBkaXJuYW1lLCBqb2luLCBub3JtYWxpemUgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvY29yZSc7XG5pbXBvcnQge1xuICBSdWxlLFxuICBTY2hlbWF0aWNzRXhjZXB0aW9uLFxuICBjaGFpbixcbiAgZXh0ZXJuYWxTY2hlbWF0aWMsXG4gIG5vb3AsXG59IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9zY2hlbWF0aWNzJztcbmltcG9ydCB7IFNjaGVtYSBhcyBVbml2ZXJzYWxPcHRpb25zIH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91bml2ZXJzYWwvc2NoZW1hJztcbmltcG9ydCB7IE5vZGVEZXBlbmRlbmN5VHlwZSwgYWRkUGFja2FnZUpzb25EZXBlbmRlbmN5IH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L2RlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBKU09ORmlsZSB9IGZyb20gJ0BzY2hlbWF0aWNzL2FuZ3VsYXIvdXRpbGl0eS9qc29uLWZpbGUnO1xuaW1wb3J0IHsgdXBkYXRlV29ya3NwYWNlIH0gZnJvbSAnQHNjaGVtYXRpY3MvYW5ndWxhci91dGlsaXR5L3dvcmtzcGFjZSc7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtcbiAgYWRkSW5pdGlhbE5hdmlnYXRpb24sXG4gIGZpbmRJbXBvcnQsXG4gIGdldEltcG9ydE9mSWRlbnRpZmllcixcbiAgZ2V0T3V0cHV0UGF0aCxcbiAgZ2V0UHJvamVjdCxcbiAgc3RyaXBUc0V4dGVuc2lvbixcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBTRVJWRV9TU1JfVEFSR0VUX05BTUUgPSAnc2VydmUtc3NyJztcbmNvbnN0IFBSRVJFTkRFUl9UQVJHRVRfTkFNRSA9ICdwcmVyZW5kZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFkZFVuaXZlcnNhbE9wdGlvbnMgZXh0ZW5kcyBVbml2ZXJzYWxPcHRpb25zIHtcbiAgc2VydmVyRmlsZU5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVbml2ZXJzYWxDb21tb25SdWxlKG9wdGlvbnM6IEFkZFVuaXZlcnNhbE9wdGlvbnMpOiBSdWxlIHtcbiAgcmV0dXJuIGFzeW5jIGhvc3QgPT4ge1xuICAgIGNvbnN0IGNsaWVudFByb2plY3QgPSBhd2FpdCBnZXRQcm9qZWN0KGhvc3QsIG9wdGlvbnMuY2xpZW50UHJvamVjdCk7XG5cbiAgICByZXR1cm4gY2hhaW4oW1xuICAgICAgY2xpZW50UHJvamVjdC50YXJnZXRzLmhhcygnc2VydmVyJylcbiAgICAgICAgPyBub29wKClcbiAgICAgICAgOiBleHRlcm5hbFNjaGVtYXRpYygnQHNjaGVtYXRpY3MvYW5ndWxhcicsICd1bml2ZXJzYWwnLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBza2lwSW5zdGFsbDogdHJ1ZVxuICAgICAgICB9KSxcbiAgICAgIGFkZFNjcmlwdHNSdWxlKG9wdGlvbnMpLFxuICAgICAgdXBkYXRlU2VydmVyVHNDb25maWdSdWxlKG9wdGlvbnMpLFxuICAgICAgdXBkYXRlV29ya3NwYWNlQ29uZmlnUnVsZShvcHRpb25zKSxcbiAgICAgIHJvdXRpbmdJbml0aWFsTmF2aWdhdGlvblJ1bGUob3B0aW9ucyksXG4gICAgICBhZGREZXBlbmRlbmNpZXMoKSxcbiAgICBdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU2NyaXB0c1J1bGUob3B0aW9uczogQWRkVW5pdmVyc2FsT3B0aW9ucyk6IFJ1bGUge1xuICByZXR1cm4gYXN5bmMgaG9zdCA9PiB7XG4gICAgY29uc3QgcGtnUGF0aCA9ICcvcGFja2FnZS5qc29uJztcbiAgICBjb25zdCBidWZmZXIgPSBob3N0LnJlYWQocGtnUGF0aCk7XG4gICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFNjaGVtYXRpY3NFeGNlcHRpb24oJ0NvdWxkIG5vdCBmaW5kIHBhY2thZ2UuanNvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlckRpc3QgPSBhd2FpdCBnZXRPdXRwdXRQYXRoKGhvc3QsIG9wdGlvbnMuY2xpZW50UHJvamVjdCwgJ3NlcnZlcicpO1xuICAgIGNvbnN0IHBrZyA9IEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCkpO1xuICAgIHBrZy5zY3JpcHRzID0ge1xuICAgICAgLi4ucGtnLnNjcmlwdHMsXG4gICAgICAnZGV2OnNzcic6IGBuZyBydW4gJHtvcHRpb25zLmNsaWVudFByb2plY3R9OiR7U0VSVkVfU1NSX1RBUkdFVF9OQU1FfWAsXG4gICAgICAnc2VydmU6c3NyJzogYG5vZGUgJHtzZXJ2ZXJEaXN0fS9tYWluLmpzYCxcbiAgICAgICdidWlsZDpzc3InOiBgbmcgYnVpbGQgLS1wcm9kICYmIG5nIHJ1biAke29wdGlvbnMuY2xpZW50UHJvamVjdH06c2VydmVyOnByb2R1Y3Rpb25gLFxuICAgICAgJ3ByZXJlbmRlcic6IGBuZyBydW4gJHtvcHRpb25zLmNsaWVudFByb2plY3R9OiR7UFJFUkVOREVSX1RBUkdFVF9OQU1FfWAsXG4gICAgfTtcblxuICAgIGhvc3Qub3ZlcndyaXRlKHBrZ1BhdGgsIEpTT04uc3RyaW5naWZ5KHBrZywgbnVsbCwgMikpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3Jrc3BhY2VDb25maWdSdWxlKG9wdGlvbnM6IEFkZFVuaXZlcnNhbE9wdGlvbnMpOiBSdWxlIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gdXBkYXRlV29ya3NwYWNlKHdvcmtzcGFjZSA9PiB7XG4gICAgICBjb25zdCBwcm9qZWN0TmFtZSA9IG9wdGlvbnMuY2xpZW50UHJvamVjdDtcbiAgICAgIGNvbnN0IHByb2plY3QgPSB3b3Jrc3BhY2UucHJvamVjdHMuZ2V0KHByb2plY3ROYW1lKTtcbiAgICAgIGlmICghcHJvamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlcnZlclRhcmdldCA9IHByb2plY3QudGFyZ2V0cy5nZXQoJ3NlcnZlcicpO1xuICAgICAgc2VydmVyVGFyZ2V0Lm9wdGlvbnMubWFpbiA9IGpvaW4oXG4gICAgICAgIG5vcm1hbGl6ZShwcm9qZWN0LnJvb3QpLFxuICAgICAgICBzdHJpcFRzRXh0ZW5zaW9uKG9wdGlvbnMuc2VydmVyRmlsZU5hbWUpICsgJy50cycsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzZXJ2ZVNTUlRhcmdldCA9IHByb2plY3QudGFyZ2V0cy5nZXQoU0VSVkVfU1NSX1RBUkdFVF9OQU1FKTtcbiAgICAgIGlmIChzZXJ2ZVNTUlRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByb2plY3QudGFyZ2V0cy5hZGQoe1xuICAgICAgICBuYW1lOiBTRVJWRV9TU1JfVEFSR0VUX05BTUUsXG4gICAgICAgIGJ1aWxkZXI6ICdAbmd1bml2ZXJzYWwvYnVpbGRlcnM6c3NyLWRldi1zZXJ2ZXInLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYnJvd3NlclRhcmdldDogYCR7cHJvamVjdE5hbWV9OmJ1aWxkYCxcbiAgICAgICAgICBzZXJ2ZXJUYXJnZXQ6IGAke3Byb2plY3ROYW1lfTpzZXJ2ZXJgLFxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmF0aW9uczoge1xuICAgICAgICAgIHByb2R1Y3Rpb246IHtcbiAgICAgICAgICAgIGJyb3dzZXJUYXJnZXQ6IGAke3Byb2plY3ROYW1lfTpidWlsZDpwcm9kdWN0aW9uYCxcbiAgICAgICAgICAgIHNlcnZlclRhcmdldDogYCR7cHJvamVjdE5hbWV9OnNlcnZlcjpwcm9kdWN0aW9uYCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHByZXJlbmRlclRhcmdldCA9IHByb2plY3QudGFyZ2V0cy5nZXQoUFJFUkVOREVSX1RBUkdFVF9OQU1FKTtcbiAgICAgIGlmIChwcmVyZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwcm9qZWN0LnRhcmdldHMuYWRkKHtcbiAgICAgICAgbmFtZTogUFJFUkVOREVSX1RBUkdFVF9OQU1FLFxuICAgICAgICBidWlsZGVyOiAnQG5ndW5pdmVyc2FsL2J1aWxkZXJzOnByZXJlbmRlcicsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBicm93c2VyVGFyZ2V0OiBgJHtwcm9qZWN0TmFtZX06YnVpbGQ6cHJvZHVjdGlvbmAsXG4gICAgICAgICAgc2VydmVyVGFyZ2V0OiBgJHtwcm9qZWN0TmFtZX06c2VydmVyOnByb2R1Y3Rpb25gLFxuICAgICAgICAgIHJvdXRlczogWycvJ11cbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkIGEgZHVtbXkgcHJvZHVjdGlvbiBjb25maWcgdG8gYmUgY29uc2lzdGVudCB3aXRoIG90aGVyIHRhcmdldHMuXG4gICAgICAgIGNvbmZpZ3VyYXRpb25zOiB7XG4gICAgICAgICAgcHJvZHVjdGlvbjoge1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2VydmVyVHNDb25maWdSdWxlKG9wdGlvbnM6IEFkZFVuaXZlcnNhbE9wdGlvbnMpOiBSdWxlIHtcbiAgcmV0dXJuIGFzeW5jIGhvc3QgPT4ge1xuICAgIGNvbnN0IGNsaWVudFByb2plY3QgPSBhd2FpdCBnZXRQcm9qZWN0KGhvc3QsIG9wdGlvbnMuY2xpZW50UHJvamVjdCk7XG4gICAgY29uc3Qgc2VydmVyVGFyZ2V0ID0gY2xpZW50UHJvamVjdC50YXJnZXRzLmdldCgnc2VydmVyJyk7XG4gICAgaWYgKCFzZXJ2ZXJUYXJnZXQgfHwgIXNlcnZlclRhcmdldC5vcHRpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHNDb25maWdQYXRoID0gc2VydmVyVGFyZ2V0Lm9wdGlvbnMudHNDb25maWc7XG4gICAgaWYgKCF0c0NvbmZpZ1BhdGggfHwgdHlwZW9mIHRzQ29uZmlnUGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIE5vIHRzY29uZmlnIHBhdGhcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0c0NvbmZpZyA9IG5ldyBKU09ORmlsZShob3N0LCB0c0NvbmZpZ1BhdGgpO1xuICAgIGNvbnN0IGZpbGVzQXN0Tm9kZSA9IHRzQ29uZmlnLmdldChbJ2ZpbGVzJ10pO1xuICAgIGNvbnN0IHNlcnZlckZpbGVQYXRoID0gc3RyaXBUc0V4dGVuc2lvbihvcHRpb25zLnNlcnZlckZpbGVOYW1lKSArICcudHMnO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGVzQXN0Tm9kZSkgJiYgIWZpbGVzQXN0Tm9kZS5zb21lKCh7IHRleHQgfSkgPT4gdGV4dCA9PT0gc2VydmVyRmlsZVBhdGgpKSB7XG4gICAgICB0c0NvbmZpZy5tb2RpZnkoWydmaWxlcyddLCBbXG4gICAgICAgIC4uLmZpbGVzQXN0Tm9kZSxcbiAgICAgICAgc2VydmVyRmlsZVBhdGhcbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcm91dGluZ0luaXRpYWxOYXZpZ2F0aW9uUnVsZShvcHRpb25zOiBVbml2ZXJzYWxPcHRpb25zKTogUnVsZSB7XG4gIHJldHVybiBhc3luYyBob3N0ID0+IHtcbiAgICBjb25zdCBjbGllbnRQcm9qZWN0ID0gYXdhaXQgZ2V0UHJvamVjdChob3N0LCBvcHRpb25zLmNsaWVudFByb2plY3QpO1xuICAgIGNvbnN0IHNlcnZlclRhcmdldCA9IGNsaWVudFByb2plY3QudGFyZ2V0cy5nZXQoJ3NlcnZlcicpO1xuICAgIGlmICghc2VydmVyVGFyZ2V0IHx8ICFzZXJ2ZXJUYXJnZXQub3B0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRzQ29uZmlnUGF0aCA9IHNlcnZlclRhcmdldC5vcHRpb25zLnRzQ29uZmlnO1xuICAgIGlmICghdHNDb25maWdQYXRoIHx8IHR5cGVvZiB0c0NvbmZpZ1BhdGggIT09ICdzdHJpbmcnIHx8ICFob3N0LmV4aXN0cyh0c0NvbmZpZ1BhdGgpKSB7XG4gICAgICAvLyBObyB0c2NvbmZpZyBwYXRoXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VDb25maWdIb3N0OiB0cy5QYXJzZUNvbmZpZ0hvc3QgPSB7XG4gICAgICB1c2VDYXNlU2Vuc2l0aXZlRmlsZU5hbWVzOiB0cy5zeXMudXNlQ2FzZVNlbnNpdGl2ZUZpbGVOYW1lcyxcbiAgICAgIHJlYWREaXJlY3Rvcnk6IHRzLnN5cy5yZWFkRGlyZWN0b3J5LFxuICAgICAgZmlsZUV4aXN0czogZnVuY3Rpb24gKGZpbGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGhvc3QuZXhpc3RzKGZpbGVOYW1lKTtcbiAgICAgIH0sXG4gICAgICByZWFkRmlsZTogZnVuY3Rpb24gKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gaG9zdC5yZWFkKGZpbGVOYW1lKS50b1N0cmluZygpO1xuICAgICAgfSxcbiAgICB9O1xuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0cy5yZWFkQ29uZmlnRmlsZSh0c0NvbmZpZ1BhdGgsIHBhcnNlQ29uZmlnSG9zdC5yZWFkRmlsZSk7XG4gICAgY29uc3QgcGFyc2VkID0gdHMucGFyc2VKc29uQ29uZmlnRmlsZUNvbnRlbnQoXG4gICAgICBjb25maWcsXG4gICAgICBwYXJzZUNvbmZpZ0hvc3QsXG4gICAgICBkaXJuYW1lKG5vcm1hbGl6ZSh0c0NvbmZpZ1BhdGgpKSxcbiAgICApO1xuICAgIGNvbnN0IHRzSG9zdCA9IHRzLmNyZWF0ZUNvbXBpbGVySG9zdChwYXJzZWQub3B0aW9ucywgdHJ1ZSk7XG4gICAgLy8gU3RyaXAgQk9NIGFzIG90aGVyd2lzZSBUU0MgbWV0aG9kcyAoRXg6IGdldFdpZHRoKSB3aWxsIHJldHVybiBhbiBvZmZzZXQsXG4gICAgLy8gd2hpY2ggYnJlYWtzIHRoZSBDTEkgVXBkYXRlUmVjb3JkZXIuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMzA3MTlcbiAgICB0c0hvc3QucmVhZEZpbGUgPSBmdW5jdGlvbiAoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICByZXR1cm4gaG9zdC5yZWFkKGZpbGVOYW1lKS50b1N0cmluZygpLnJlcGxhY2UoL15cXHVGRUZGLywgJycpO1xuICAgIH07XG4gICAgdHNIb3N0LmRpcmVjdG9yeUV4aXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RvcnlOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgIC8vIFdoZW4gdGhlIHBhdGggaXMgZmlsZSBnZXREaXIgd2lsbCB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGhvc3QuZ2V0RGlyKGRpcmVjdG9yeU5hbWUpO1xuXG4gICAgICAgIHJldHVybiAhIShkaXIuc3ViZGlycy5sZW5ndGggfHwgZGlyLnN1YmZpbGVzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdHNIb3N0LmZpbGVFeGlzdHMgPSBmdW5jdGlvbiAoZmlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGhvc3QuZXhpc3RzKGZpbGVOYW1lKTtcbiAgICB9O1xuICAgIHRzSG9zdC5yZWFscGF0aCA9IGZ1bmN0aW9uIChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICB0c0hvc3QuZ2V0Q3VycmVudERpcmVjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBob3N0LnJvb3QucGF0aDtcbiAgICB9O1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRzLmNyZWF0ZVByb2dyYW0ocGFyc2VkLmZpbGVOYW1lcywgcGFyc2VkLm9wdGlvbnMsIHRzSG9zdCk7XG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSBwcm9ncmFtLmdldFR5cGVDaGVja2VyKCk7XG4gICAgY29uc3Qgc291cmNlRmlsZXMgPSBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCkuZmlsdGVyKFxuICAgICAgZiA9PiAhZi5pc0RlY2xhcmF0aW9uRmlsZSAmJiAhcHJvZ3JhbS5pc1NvdXJjZUZpbGVGcm9tRXh0ZXJuYWxMaWJyYXJ5KGYpKTtcbiAgICBjb25zdCBwcmludGVyID0gdHMuY3JlYXRlUHJpbnRlcigpO1xuICAgIGNvbnN0IHJvdXRlck1vZHVsZSA9ICdSb3V0ZXJNb2R1bGUnO1xuICAgIGNvbnN0IHJvdXRlclNvdXJjZSA9ICdAYW5ndWxhci9yb3V0ZXInO1xuXG4gICAgc291cmNlRmlsZXMuZm9yRWFjaChzb3VyY2VGaWxlID0+IHtcbiAgICAgIGNvbnN0IHJvdXRlckltcG9ydCA9IGZpbmRJbXBvcnQoc291cmNlRmlsZSwgcm91dGVyU291cmNlLCByb3V0ZXJNb2R1bGUpO1xuICAgICAgaWYgKCFyb3V0ZXJJbXBvcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgcm91dGVyTW9kdWxlTm9kZTogdHMuQ2FsbEV4cHJlc3Npb247XG4gICAgICB0cy5mb3JFYWNoQ2hpbGQoc291cmNlRmlsZSwgZnVuY3Rpb24gdmlzaXROb2RlKG5vZGU6IHRzLk5vZGUpIHtcbiAgICAgICAgaWYgKHRzLmlzQ2FsbEV4cHJlc3Npb24obm9kZSkgJiYgdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSAmJlxuICAgICAgICAgIHRzLmlzSWRlbnRpZmllcihub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbikgJiYgbm9kZS5leHByZXNzaW9uLm5hbWUudGV4dCA9PT0gJ2ZvclJvb3QnKSB7XG4gICAgICAgICAgY29uc3QgaW1wID0gZ2V0SW1wb3J0T2ZJZGVudGlmaWVyKHR5cGVDaGVja2VyLCBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG5cbiAgICAgICAgICBpZiAoaW1wICYmIGltcC5uYW1lID09PSByb3V0ZXJNb2R1bGUgJiYgaW1wLmltcG9ydE1vZHVsZSA9PT0gcm91dGVyU291cmNlKSB7XG4gICAgICAgICAgICByb3V0ZXJNb2R1bGVOb2RlID0gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cy5mb3JFYWNoQ2hpbGQobm9kZSwgdmlzaXROb2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocm91dGVyTW9kdWxlTm9kZSkge1xuICAgICAgICBjb25zdCBwcmludCA9IHByaW50ZXIucHJpbnROb2RlKFxuICAgICAgICAgIHRzLkVtaXRIaW50LlVuc3BlY2lmaWVkLCBhZGRJbml0aWFsTmF2aWdhdGlvbihyb3V0ZXJNb2R1bGVOb2RlKSxcbiAgICAgICAgICBzb3VyY2VGaWxlKTtcblxuICAgICAgICBjb25zdCByZWNvcmRlciA9IGhvc3QuYmVnaW5VcGRhdGUoc291cmNlRmlsZS5maWxlTmFtZSk7XG4gICAgICAgIHJlY29yZGVyLnJlbW92ZShyb3V0ZXJNb2R1bGVOb2RlLmdldFN0YXJ0KCksIHJvdXRlck1vZHVsZU5vZGUuZ2V0V2lkdGgoKSk7XG4gICAgICAgIHJlY29yZGVyLmluc2VydFJpZ2h0KHJvdXRlck1vZHVsZU5vZGUuZ2V0U3RhcnQoKSwgcHJpbnQpO1xuICAgICAgICBob3N0LmNvbW1pdFVwZGF0ZShyZWNvcmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZERlcGVuZGVuY2llcygpOiBSdWxlIHtcbiAgcmV0dXJuIGhvc3QgPT4ge1xuICAgIGFkZFBhY2thZ2VKc29uRGVwZW5kZW5jeShob3N0LCB7XG4gICAgICBuYW1lOiAnQG5ndW5pdmVyc2FsL2J1aWxkZXJzJyxcbiAgICAgIHR5cGU6IE5vZGVEZXBlbmRlbmN5VHlwZS5EZXYsXG4gICAgICB2ZXJzaW9uOiAnXjAuMC4wLVBMQUNFSE9MREVSJyxcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0O1xuICB9O1xufVxuIl19